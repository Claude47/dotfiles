#!/usr/bin/env python

from collections import defaultdict
from Crypto.Cipher import AES
import click
import hashlib
import os
import pickle
import pyperclip
import random
import subprocess


DEFAULTPATH = os.path.expanduser('~/.storepass-data')


def encrypt(text, password):
    """
    AES (CFB) encrypt 'text' with 'password'.
    """
    key = hashlib.sha1(password).hexdigest()[:32]
    iv = os.urandom(16)
    aes_obj = AES.new(key, AES.MODE_CFB, iv)
    return iv + aes_obj.encrypt(text)


def decrypt(encoded, password):
    """
    Decrypt an AES (CFB) encrypted string with a 16-byte prepended IV.
    """
    key = hashlib.sha1(password).hexdigest()[:32]
    iv = encoded[:16]
    aes_obj = AES.new(key, AES.MODE_CFB, iv)
    return aes_obj.decrypt(encoded[16:])


def write_database(pd, password, filename):
    """
    Serialize, encrypt and store object to file.
    """
    try:
        enc = encrypt(pickle.dumps(pd), password)
        with open(filename, 'wb') as output_file:
            pickle.dump(enc, output_file, -1)
        return True
    except:
        return False


def read_database(password, filename):
    """
    Read, decrypt and deserialize object from file.
    """
    try:
        enc = pickle.load(open(filename, 'rb'))
        return pickle.loads(decrypt(enc, password))
    except:
        return False


def paste_to_clipboard(text, timeout=0):
    """
    Copy text to clipboard.
    """
    pyperclip.copy(text)
    if timeout:
        command = 'sleep {} && python -c ' \
                  '"import pyperclip;pyperclip.copy(\'\');"'.format(timeout)
        subprocess.Popen(command, stdin=subprocess.PIPE, shell=True)


def random_password(length):
    """
    Generates a random password.
    """
    letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' \
              '01234567890-=!@#$%^&_+'
    return ''.join(random.sample(letters[:52], 1) +
                   random.sample(letters, length - 2) +
                   random.sample(letters[:52], 1))


def paths_to_tree(subset):
    """
    Construct a tree structure from paths using defaultdict.
    """
    def tree():
        return defaultdict(tree)

    def add(t, path):
        for node in path:
            t = t[node]

    t = tree()
    for path, password in subset.items():
        add(t, path.split('/'))
    return t


def print_tree(tree, indent=0):
    """
    Recursively print tree structure.
    """
    for k in sorted(tree):
        click.echo(indent * '|   ' + '|-- ' + k)
        print_tree(tree[k], indent=indent + 1)


def get_database():
    """
    Ask user for master password and read in database.
    """
    if os.path.isfile(DEFAULTPATH):
        master = click.prompt('Enter master password', hide_input=True)
        pd = read_database(master, DEFAULTPATH)
        if not isinstance(pd, dict):
            click.echo('Unable to decrypt database.')
            raise click.Abort()
        return pd, master
    else:
        click.echo('No password database found.\n'
                   'Use the \'init\' command to initialize one.')
        raise click.Abort()


@click.group(context_settings=dict(help_option_names=['-h', '--help']))
def cli():
    """
    Encrypt and store passwords in a file.

    Use the 'init' command to initialize a password database, encrypted with a
    master password. Passwords can then be added using the 'store' command and
    retrieved using the 'get' command. By default when retrieving passwords
    they are copied to the clipboard. All the names of entries in the database
    can be printed out using the 'ls' command. Passwords are stored with a
    corresponding label. If this label contains forward slashes then the 'ls'
    command will print a directory structure.

    The database is encrypted using AES encryption (CFB mode) with a randomly
    generated IV and a key generated by SHA1 hashing the master password.
    """
    pass


@cli.command()
def init():
    """
    Initialize database.
    """
    if os.path.isfile(DEFAULTPATH):
        click.confirm('A password database already exists at "{}".\n'
                      'Do you want to overwrite it?'.format(DEFAULTPATH),
                      abort=True)
    else:
        click.echo('A new password database will be created.')

    password = click.prompt('Enter new master password', hide_input=True,
                            confirmation_prompt=True)
    if write_database(dict(), password, DEFAULTPATH):
        click.echo('Initialized new password database.')
    else:
        click.echo('Error: Unable to initialize new password database.')


@cli.command()
@click.argument('label')
@click.option('--generate', '-g', default=0,
              help='Generate a random password of given length.')
def store(label, generate):
    """
    Add or update an entry.

    LABEL is the path-like tag for the password.

    This command will prompt for the entry's password.
    """
    pd, master = get_database()
    if label in pd:
        click.confirm('Entry already exists. Update?', abort=True)
    if generate:
        password = random_password(generate)
        paste_to_clipboard(password, timeout=45)
        click.echo('Password generated and copied to clipboard.\n'
                   'The clipboard will clear in 45 seconds.')
    else:
        password = click.prompt('Enter password for entry', hide_input=True,
                                confirmation_prompt=True)
    pd[label] = password
    click.echo('Stored label and password.')
    if not write_database(pd, master, DEFAULTPATH):
        click.echo('Error: Unable to encrypt database to file.')


@cli.command()
@click.argument('label')
@click.option('--clipboard/--no-clipboard', default=True,
              help='Whether to paste to clipboard or print to terminal.')
def get(label, clipboard):
    """
    Retrieve password from database.

    LABEL is the path-like tag for the password.

    The retrieved password will be copied to the clipboard unless otherwise
    specified.
    """
    pd, master = get_database()
    subset = {k: v for k, v in pd.items() if k.startswith(label)}
    if len(subset) == 1:
        label = subset.keys()[0]
    if label in pd:
        if clipboard:
            paste_to_clipboard(pd[label], timeout=45)
            click.echo('Password copied to clipboard.\n'
                       'The clipboard will clear in 45 seconds.')
        else:
            click.echo('The password is: {}'.format(pd[label]))
    elif subset:
        click.echo('More than one entry.')
    else:
        click.echo('Entry does not exist.')


@cli.command()
@click.argument('label', required=False)
def ls(label):
    """
    List stored entries.

    LABEL is the path-like tag for the password.
    """
    pd, master = get_database()
    subset = {k: v for k, v in pd.items() if not label or k.startswith(label)}
    if subset:
        click.echo('Password Database')
        print_tree(paths_to_tree(subset))
    elif label:
        click.echo('No entries starting with "{}".'.format(label))
    else:
        click.echo('No entries to show.')


@cli.command()
@click.argument('label')
def rm(label):
    """
    Remove stored entries.

    LABEL is the path-like tag for the password.
    """
    pd, master = get_database()
    subset = [k for k in sorted(pd) if k.startswith(label)]
    if len(subset) > 0:
        entries = '\n '.join(k for k in subset)
        click.confirm('Are you sure you want to delete the following '
                      'entries?\n {}\n'.format(entries), abort=True)
        for k in subset:
            del pd[k]
        click.echo('Removed {} entries.'.format(len(subset)))
        if not write_database(pd, master, DEFAULTPATH):
            click.echo('Error: Unable to encrypt database to file.')
    else:
        click.echo('No entries starting with "{}".'.format(label))


@cli.command()
@click.argument('old-label')
@click.argument('new-label')
def mv(old_label, new_label):
    """
    Rename a password label.
    """
    pd, master = get_database()
    if old_label in pd:
        click.confirm('Are you sure you want to rename "{}" to "{}"?'
                      .format(old_label, new_label), abort=True)
        pd[new_label] = pd[old_label]
        del pd[old_label]
        click.echo('Renamed entry.')
        if not write_database(pd, master, DEFAULTPATH):
            click.echo('Error: Unable to encrypt database to file.')
    else:
        click.echo('Entry does not exist.')


@cli.command(name='set-key')
def set_key():
    """
    Update master password.
    """
    pd, master = get_database()
    password = click.prompt('Enter new master password for database', type=str,
                            hide_input=True, confirmation_prompt=True)
    if write_database(pd, password, DEFAULTPATH):
        click.echo('Successfully changed master password.')
    else:
        click.echo('Error: Unable to change master password.')


if __name__ == '__main__':
    cli()
